{"remainingRequest":"/Users/bianchi_dy/Documents/GitHub/aviation-viz/routes/viz/routes-network/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/bianchi_dy/Documents/GitHub/aviation-viz/routes/viz/routes-network/src/components/NetworkC.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/bianchi_dy/Documents/GitHub/aviation-viz/routes/viz/routes-network/src/components/NetworkC.vue","mtime":1622539983744},{"path":"/Users/bianchi_dy/Documents/GitHub/aviation-viz/routes/viz/routes-network/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/bianchi_dy/Documents/GitHub/aviation-viz/routes/viz/routes-network/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gImQzIjsKaW1wb3J0IHsganNvbiwgY3N2IH0gZnJvbSAnZDMtZmV0Y2gnCi8vJy4uL2Fzc2V0cy9qcy9teWtleS5qcycKLy8gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5pbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogIm5ldHdvcmsiLAogIHByb3BzOiB7CiAgICBqc29uVVJMOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogKCkgPT4gJ3JvdXRlc19kZWdyZWUuanNvbicKICAgIH0sCgogICAgbGlua0Rpc3RhbmNlOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMzAKICAgIH0sCiAgICAvLyBzdmcKICAgIHN2Z1NpemU6IHsKICAgICAgdHlwZTogT2JqZWN0LAogICAgICBkZWZhdWx0OiAoKSA9PiB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCwKICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0CiAgICAgICAgfTsKICAgICAgfQogICAgfSwKCiAgICBib2R5U3RyZW5ndGg6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAtMjAwCiAgICB9LAoKICAgIGhlaWdodDogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIGRlZmF1bHQ6IDgwMAogICAgfSwKICAgIAogICAgd2lkdGg6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAxNDAwCiAgICB9LAoKICAgIHNsaWRlclZhbHVlOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMTAwCiAgICB9LAoKICAgIG1hcmdpbjogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdG9wOiA1LAogICAgICAgICAgcmlnaHQ6IDUsCiAgICAgICAgICBib3R0b206IDUsCiAgICAgICAgICBsZWZ0OiA1CiAgICAgICAgfQogICAgICB9CiAgICB9IAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGJiQm94TWFyZ2luOiAyMCwKICAgICAgc2VsZWN0aW9uOiB7CiAgICAgICAgbGlua3M6IFtdLAogICAgICAgIG5vZGVzOiBbXQogICAgICB9LAogICAgICBwaW5uZWQ6IFtdLCAKICAgICAgbm9kZUxpc3Q6IFtdLAogICAgICBsaW5rTGlzdDogW10sCiAgICAgIGZvcmNlOiBudWxsLAogICAgICB6b29tOiBkMy56b29tKCksCiAgICAgIHRyYW5zaXRpb25TcGVlZDogMjAwLAogICAgICBjdXJ2ZXM6IHRydWUsCiAgICAgIHN0ZXBwZXI6IDAsCiAgICAgIGxpbmtTdHJva2U6ICdncmF5JywKICAgICAgYnRuczogWydkX2NlbnRyYWxpdHknLCAnY19jZW50cmFsaXR5JywgJ2JfY2VudHJhbGl0eSddLAogICAgICBjX2NlbnRyYWxpdHk6IFtdLAogICAgICBiX2NlbnRyYWxpdHk6IFtdLAogICAgICBkX2NlbnRyYWxpdHk6IFtdLAogICAgICByYWRpdXNSYW5nZTogWzEsIDEwXSwKICAgICAgZm9udHNpemU6MTYsIAogICAgICBhY3RpdmVTY2FsZTogJ2RfY2VudHJhbGl0eScsCiAgICAgIGRlc2NyaXB0aW9uOiB7J2RfY2VudHJhbGl0eSc6ICcgRGVncmVlIGNlbnRyYWxpdHksIHdoaWNoIGlzIGRlZmluZWQgYXMgdGhlIG51bWJlciBvZiBsaW5rcyBpbmNpZGVudCB1cG9uIGEgbm9kZSAoaS5lLiwgdGhlIG51bWJlciBvZiB0aWVzIHRoYXQgYSBub2RlIGhhcykuIFRoZSBkZWdyZWUgY2FuIGJlIGludGVycHJldGVkIGluIHRlcm1zIG9mIHRoZSBpbW1lZGlhdGUgcmlzayBvZiBhIG5vZGUgZm9yIGNhdGNoaW5nIHdoYXRldmVyIGlzIGZsb3dpbmcgdGhyb3VnaCB0aGUgbmV0d29yayAoc3VjaCBhcyBhIHZpcnVzLCBvciBzb21lIGluZm9ybWF0aW9uKS4nLAogICAgICAgICdjX2NlbnRyYWxpdHknOiAndGhlIG5vcm1hbGl6ZWQgY2xvc2VuZXNzIGNlbnRyYWxpdHkgKG9yIGNsb3NlbmVzcykgb2YgYSBub2RlIGlzIHRoZSBhdmVyYWdlIGxlbmd0aCBvZiB0aGUgc2hvcnRlc3QgcGF0aCBiZXR3ZWVuIHRoZSBub2RlIGFuZCBhbGwgb3RoZXIgbm9kZXMgaW4gdGhlIGdyYXBoLiBUaHVzIHRoZSBtb3JlIGNlbnRyYWwgYSBub2RlIGlzLCB0aGUgY2xvc2VyIGl0IGlzIHRvIGFsbCBvdGhlciBub2Rlcy4nLAogICAgICAgICdiX2NlbnRyYWxpdHknOiAnQmV0d2Vlbm5lc3MgY2VudHJhbGl0eSBxdWFudGlmaWVzIHRoZSBudW1iZXIgb2YgdGltZXMgYSBub2RlIGFjdHMgYXMgYSBicmlkZ2UgYWxvbmcgdGhlIHNob3J0ZXN0IHBhdGggYmV0d2VlbiB0d28gb3RoZXIgbm9kZXMuIEl0IHdhcyBpbnRyb2R1Y2VkIGFzIGEgbWVhc3VyZSBmb3IgcXVhbnRpZnlpbmcgdGhlIGNvbnRyb2wgb2YgYSBodW1hbiBvbiB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIG90aGVyIGh1bWFucyBpbiBhIHNvY2lhbCBuZXR3b3JrJ30KICAgIH07CiAgfSwKICBjb21wdXRlZDogewogICAgbm9kZXMoKSB7CiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9kZUxpc3Quc2xpY2UoKTsKICAgICAgbGV0IG5vZGVJZHMgPSBbXTsKICAgICAgbm9kZXMgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7CiAgICAgICAgaWYgKG5vZGVJZHMuaW5kZXhPZihub2RlLmlkKSA9PT0gLTEpIHsKICAgICAgICAgIG5vZGVJZHMucHVzaChub2RlLmlkKTsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgcmV0dXJuIG5vZGVzOwogICAgfSwKCiAgICBsaW5rcygpIHsKICAgICAgcmV0dXJuIHRoaXMubGlua0xpc3Q7CiAgICB9LAoKICAgIGFjdGl2ZURvbWFpbigpIHsKICAgICAgaWYgKHRoaXMuYWN0aXZlU2NhbGUgPT09ICdkX2NlbnRyYWxpdHknKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZF9jZW50cmFsaXR5CiAgICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmVTY2FsZSA9PT0gJ2JfY2VudHJhbGl0eScpIHsKICAgICAgICByZXR1cm4gdGhpcy5iX2NlbnRyYWxpdHkKICAgICAgfSBlbHNlIGlmICh0aGlzLmFjdGl2ZVNjYWxlID09PSAnY19jZW50cmFsaXR5Jyl7CiAgICAgICAgcmV0dXJuIHRoaXMuY19jZW50cmFsaXR5CiAgICAgIH0KICAgIH0sCgogICAgY2VudHJhbGl0eVNjYWxlKCkgewogICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4odGhpcy5hY3RpdmVEb21haW4pLnJhbmdlKFsnd2hpdGUnLCAnI0RBMEUwRSddKQogICAgfSAKICB9LAogIHdhdGNoOiB7CiAgICBzbGlkZXJWYWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgIHRoaXMuc3ZnLnNlbGVjdEFsbCgnLm5vZGUtdGV4dCcpCiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkKICAgICAgICAuYXR0cignb3BhY2l0eScsIGQgPT4gZC5vY2N1cmVuY2UgPiB0aGlzLnNsaWRlclZhbHVlID8gMSA6IDApOwogICAgICB0aGlzLiRmb3JjZVVwZGF0ZSgpOwogICAgfSwKICAgIGJvZHlTdHJlbmd0aDogZnVuY3Rpb24oKSB7CiAgICAgIHRoaXMuaW5pdERhdGEoKTsKICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKSB7CiAgICAgICAgdGhpcy5pbml0RHJhZ1RpY2tab29tKCk7CiAgICAgIH0pOwogICAgfSwKICAgIGxpbmtEaXN0YW5jZTogZnVuY3Rpb24oKSB7CiAgICAgIHRoaXMuaW5pdERhdGEoKTsKICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKSB7CiAgICAgICAgdGhpcy5pbml0RHJhZ1RpY2tab29tKCk7CiAgICAgIH0pOwogICAgfSwKICAgIG5vZGVzOiBmdW5jdGlvbigpIHsKICAgICAgdGhpcy5pbml0RGF0YSgpOwogICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpIHsKICAgICAgICB0aGlzLmluaXREcmFnVGlja1pvb20oKTsKICAgICAgfSk7CiAgICB9CiAgfSwKCiAgY3JlYXRlZCgpIHsKICAgIHRoaXMuaW5pdERhdGEoKTsKICB9LAoKICBtb3VudGVkKCkgewogICAgdGhpcy5nZXREYXRhKCkKICAgIHRoaXMuaW5pdERyYWdUaWNrWm9vbSgpOwogIH0sCgogIG1ldGhvZHM6IHsKICAgIGNoYW5nZUNvbG9ycygpewogICAgICBsZXQgbm9kZXMgPSB0aGlzLnN2Zy5zZWxlY3RBbGwoJy5ub2RlJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRoaXMudHJhbnNpdGlvblNwZWVkKQogICAgICAgIC5hdHRyKCdmaWxsJywgKGQpID0+IHtjb25zb2xlLmxvZyhkKTsgcmV0dXJuIHRoaXMuY2VudHJhbGl0eVNjYWxlKGRbdGhpcy5hY3RpdmVTY2FsZV0pO30gKQogICAgfSwKCiAgICB1cGRhdGUoKXsKICAgICAgZDMuc2VsZWN0KCcjY2hhcnQnKS5zZWxlY3QoJ3N2ZycpLnJlbW92ZSgpCiAgICAgIHRoaXMuc3ZnID0gdGhpcy5nZXRTdmcoKQogICAgICB0aGlzLmRyYXdDaGFydCgpCiAgICB9LAoKICAgIGdldERhdGEgKCkgewogICAgICBpZiAoIXRoaXMuanNvblVSTCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGRhdGEgb3IganNvblVSTCcpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5wcm9jZXNzSlNPTih0aGlzLmpzb25VUkwpCiAgICAgIH0KICAgIH0sCgogICAgZ2V0U3RyaW5nKHJvdykgewogICAgICBsZXQgbGFiZWwgPSByb3dbJ2NvdW50cnknXS5pbmNsdWRlcygnbWVhbicpID8gJ0F2ZXJhZ2UgdmFsdWUgZm9yICcgKyByb3dbJ2VsZW1lbnQnXSA6IHJvd1snY291bnRyeSddIAogICAgICBsZXQgdmFsdWUgPSBsYWJlbCArICc6ICcgKyAocm93W3RoaXMuYWN0aXZlSW5kZXhdID8gTWF0aC5yb3VuZChyb3dbdGhpcy5hY3RpdmVJbmRleF0gKiAxMCkgLyAxMCA6ICdOSUwnKQogICAgICByZXR1cm4gdmFsdWUKICAgIH0sCgogICAgcHJvY2Vzc0pTT04gKHVybCkgewogICAgICBqc29uKHVybCkudGhlbigoZGF0YSkgPT4gewogICAgICAgIHRoaXMubGlua0xpc3QgPSBkYXRhLmxpbmtzCiAgICAgICAgdGhpcy5ub2RlTGlzdCA9IGRhdGEubm9kZXMKCiAgICAgICAgdGhpcy5ub2RlTGlzdC5mb3JFYWNoKCBub2RlPT4gewogICAgICAgICAgdGhpcy5jX2NlbnRyYWxpdHkucHVzaChub2RlLmNfY2VudHJhbGl0eSkKICAgICAgICAgIHRoaXMuYl9jZW50cmFsaXR5LnB1c2gobm9kZS5iX2NlbnRyYWxpdHkpCiAgICAgICAgICB0aGlzLmRfY2VudHJhbGl0eS5wdXNoKG5vZGUuZF9jZW50cmFsaXR5KQogICAgICAgIH0pCgogICAgICAgIHRoaXMuY19jZW50cmFsaXR5ID0gWzAsIGQzLmV4dGVudCh0aGlzLmNfY2VudHJhbGl0eSlbMV1dCiAgICAgICAgdGhpcy5iX2NlbnRyYWxpdHkgPSBbMCwgZDMuZXh0ZW50KHRoaXMuYl9jZW50cmFsaXR5KVsxXV0KICAgICAgICB0aGlzLmRfY2VudHJhbGl0eSA9IFswLCBkMy5leHRlbnQodGhpcy5kX2NlbnRyYWxpdHkpWzFdXQogICAgICAgIHRoaXMubW91bnQgPSB0cnVlCiAgICAgICAgdGhpcy51cGRhdGUoKQogICAgICB9KQogICAgfSwKCiAgICBnZXRTdmcgKCkgewogICAgICBjb25zdCB7IHN2Z1dpZHRoLCBzdmdIZWlnaHQgfSA9IHRoaXMKICAgICAgY29uc3QgeyBtYXJnaW4gfSA9IHRoaXMKCiAgICAgIHRoaXMuc3ZnV2lkdGggPSB0aGlzLndpZHRoCiAgICAgIHRoaXMuc3ZnSGVpZ2h0ID0gdGhpcy5oZWlnaHQKICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnN2Z1dpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQKICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5zdmdIZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbQoKICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCgiI2NoYXJ0IikuYXBwZW5kKCJzdmciKQogICAgICAgICAgICAgIC5hdHRyKCJ3aWR0aCIsIHdpZHRoKQogICAgICAgICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpCiAgICAgICAgICAgICAgLmF0dHIoImlkIiwgImNvbnRhaW5lciIpOwogICAgICAgICAgICAgIC8vLmNhbGwodGhpcy5yZXNwb25zaXZlZnkpOwoKICAgICAgcmV0dXJuIHN2ZwogICAgfSwKCiAgICBkcmF3Q2hhcnQoKSB7CiAgICAgIGxldCBnID0gdGhpcy5zdmcuYXBwZW5kKCdnJykKCiAgICAgIGxldCBlZGdlcyAKICAgICAgaWYgKHRoaXMuY3VydmVzKSB7CiAgICAgICAgZWRnZXMgPSBnLmFwcGVuZCgiZyIpCiAgICAgICAgICAuc2VsZWN0QWxsKCIubGluayIpCiAgICAgICAgICAuZGF0YSh0aGlzLmxpbmtzKQogICAgICAgICAgLmpvaW4oInBhdGgiKQogICAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAwLjEpCiAgICAgICAgICAuYXR0cigic3Ryb2tlIiwgdGhpcy5saW5rU3Ryb2tlKQogICAgICAgICAgLmF0dHIoImZpbGwiLCAidHJhbnNwYXJlbnQiKQogICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCkgewogICAgICAgICAgCiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBkLnNvdXJjZS5zcGxpdCgnICcpLmpvaW4oJycpLnJlcGxhY2UoL1teXHdcc118Xy9nLCAiIik7CiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBkLnRhcmdldC5zcGxpdCgnICcpLmpvaW4oJycpLnJlcGxhY2UoL1teXHdcc118Xy9nLCAiIik7CiAgICAgICAgICAgIHJldHVybiAnbGluayBlbGVtZW50ICcgKyBzb3VyY2UgKyAnICcgKyB0YXJnZXQ7CiAgICAgICAgICAgIH0pCiAgICAgICAgICAuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKQogICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbNSwgMTBdKS5yYW5nZShbMSwgMjBdKShkLnZhbHVlKTsKICAgICAgICAgIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIGVkZ2VzID0gZy5hcHBlbmQoImciKQogICAgICAgIC5zZWxlY3RBbGwoIi5saW5rIikKICAgICAgICAuZGF0YSh0aGlzLmxpbmtzKQogICAgICAgIC5lbnRlcigpLmFwcGVuZCgibGluZSIpCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCkgewogICAgICAgICAgbGV0IHNvdXJjZSA9IGQuc291cmNlLnNwbGl0KCcgJykuam9pbignJykucmVwbGFjZSgvW15cd1xzXXxfL2csICIiKTsKICAgICAgICAgIGxldCB0YXJnZXQgPSBkLnRhcmdldC5zcGxpdCgnICcpLmpvaW4oJycpLnJlcGxhY2UoL1teXHdcc118Xy9nLCAiIik7CiAgICAgICAgICByZXR1cm4gJ2xpbmsgZWxlbWVudCAnICsgc291cmNlICsgJyAnICsgdGFyZ2V0OwogICAgICAgICAgfSkKICAgICAgICAuYXR0cignb3BhY2l0eScsIDAuMSkKICAgICAgICAuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKQogICAgICAgIC5hdHRyKCdzdHJva2UnLCB0aGlzLmxpbmtTdHJva2UpCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMSwgMzBdKS5yYW5nZShbMSwgMzBdKShkLnZhbHVlKTsKICAgICAgICAgIH0pOwogICAgICB9CgogICAgICBsZXQgbm9kZXMgPSBnLmFwcGVuZCgiZyIpCiAgICAgICAgLnNlbGVjdEFsbCgiLm5vZGUiKQogICAgICAgIC5kYXRhKHRoaXMubm9kZXMpCiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKQogICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiBkLmluZGV4KQogICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQpIHsKICAgICAgICAgIGxldCBub2RlQ2xhc3M9JycKICAgICAgICAgIHJldHVybiAnbm9kZSBlbGVtZW50ICcgKyBkLmlkLnNwbGl0KCcgJykuam9pbignJykucmVwbGFjZSgvW15cd1xzXXxfL2csICIiKTsKICAgICAgICAgIH0pCiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCkgPT4gdGhpcy5jZW50cmFsaXR5U2NhbGUoZFt0aGlzLmFjdGl2ZVNjYWxlXSkpCiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIChkKSA9PiBkLmNoaWxkID09PSB0cnVlID8gJ2dvbGRlbnJvZCcgOiAnYmxhY2snKQogICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKQogICAgICAgIC5hdHRyKCdyJywgKGQpID0+IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFsxLCAxMDBdKS5yYW5nZSh0aGlzLnJhZGl1c1JhbmdlKShkLm9jY3VyZW5jZSkpCiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCAoZCwgZSwgbm9kZXMpID0+IHRoaXMubm9kZU1vdXNlb3ZlcihkLCBlLCBub2RlcykpCiAgICAgICAgLm9uKCdtb3VzZW91dCcsIChkLCBlLCBub2RlcykgPT4gdGhpcy5ub2RlTW91c2VvdXQoZCwgZSwgbm9kZXMpKTsKCiAgICAgIGxldCBibGFja091dCA9IHRoaXMuYmxhY2tPdXQKICAgICAgCiAgICAgIC8vQWRkIHNpbmdsZSBsaW5lIHRleHQKICAgICAgZy5hcHBlbmQoImciKQogICAgICAgIC5zZWxlY3RBbGwoIi50ZXh0IikKICAgICAgICAuZGF0YSh0aGlzLm5vZGVzKQogICAgICAgIC5lbnRlcigpCiAgICAgICAgLmFwcGVuZCgndGV4dCcpCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgKGQpID0+IHsKICAgICAgICAgIGlmIChkLm9jY3VyZW5jZSA+IHRoaXMuc2xpZGVyVmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuICdlbXBoIG5vZGUtdGV4dCAnICsgZC5pZC5zcGxpdCgnICcpLmpvaW4oJycpLnJlcGxhY2UoL1teXHdcc118Xy9nLCAiIik7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuICdub2RlLXRleHQgJyArIGQuaWQuc3BsaXQoJyAnKS5qb2luKCcnKS5yZXBsYWNlKC9bXlx3XHNdfF8vZywgIiIpOwogICAgICAgIH0pCiAgICAgICAgLnRleHQoKGQpID0+IGQuaWQpCiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKQogICAgICAgIC5hdHRyKCdkeCcsIDApCiAgICAgICAgLmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsICd0ZXh0LXRvcCcpCiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpCiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsdGhpcy5mb250c2l6ZSkKICAgICAgICAuYXR0cignb3BhY2l0eScsIChkKSA9PiBkLm9jY3VyZW5jZSA+IHRoaXMuc2xpZGVyVmFsdWUgPyAxIDogMCkKICAgICAgICAub24oJ21vdXNlb3ZlcicsIChkLCBlLCBub2RlcykgPT4gdGhpcy5ub2RlTW91c2VvdmVyKGQsIGUsIG5vZGVzKSkKICAgICAgICAub24oJ21vdXNlb3V0JywgKGQsIGUsIG5vZGVzKSA9PiB0aGlzLm5vZGVNb3VzZW91dChkLCBlLCBub2RlcykpOwoKICAgICAgdGhpcy5pbml0RHJhZ1RpY2tab29tKCkKCiAgICAgIGxldCB6b29tTHZsID0gMC41OwogICAgICBsZXQgbGFzdEsgPSAwOwogICAgICAKICAgICAgdGhpcy5zdmcuY2FsbChkMy56b29tKCkKICAgICAgLmV4dGVudChbWzAsIDBdLCBbdGhpcy5zdmdXaWR0aCwgdGhpcy5zdmdIZWlnaHRdXSkKICAgICAgLnNjYWxlRXh0ZW50KFswLjI1LCA4MF0pCiAgICAgIC5vbigiem9vbSIsIHpvb21lZCkpOwoKICAgICAgZnVuY3Rpb24gem9vbWVkKCkgewogICAgICAgIGxldCBlID0gZDMuZXZlbnQKICAgICAgICAKICAgICAgICBpZihlLnRyYW5zZm9ybS5rID4gMiAmJiBsYXN0SyAhPSBlLnRyYW5zZm9ybS5rKXsKICAgICAgICAgIGxhc3RLID0gZS50cmFuc2Zvcm0uazsKICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCJ6b29tZWQiKTsKICAgICAgICAgIHpvb21MdmwgPU1hdGgubG9nMihlLnRyYW5zZm9ybS5rKTsKICAgICAgICAgIG5vZGVzLmF0dHIoInN0cm9rZS13aWR0aCIsIDEuNS96b29tTHZsICk7CiAgICAgICAgICBlZGdlcy5hdHRyKCJzdHJva2Utd2lkdGgiLCAgZCA9PiBNYXRoLnNxcnQoZC52YWx1ZSkvKHpvb21MdmwpKTsKICAgICAgICB9CiAgICAgIAogICAgICAgIGcuYXR0cigidHJhbnNmb3JtIiwgZS50cmFuc2Zvcm0pOwogICAgICB9CiAgICB9LAoKICAgIG5vZGVNb3VzZW92ZXIoZCwgZSwgbm9kZXMpIHsKICAgICAgbGV0IHRhcmdldE5vZGUgPSBub2Rlc1tlXQogICAgICB0aGlzLmFjdGl2ZU5vZGUgPSBkLmlkCiAgICAgIHRoaXMuaGlnaGxpZ2h0Tm9kZSh0aGlzLmFjdGl2ZU5vZGUsIHRydWUsIHRydWUsIHRydWUpOwogICAgICB0aGlzLiRmb3JjZVVwZGF0ZSgpOwogICAgfSwKCiAgICBoaWdobGlnaHROb2RlKG5vZGVOYW1lLCBoaWdobGlnaHRMaW5rcywgaGlnaGxpZ2h0T3RoZXJzLCBkZWNyZWFzZU9wYWNpdHkpewogICAgICBsZXQgbm9kZUNsYXNzID0gW10KICAgICAgCiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVOYW1lKSkgewogICAgICAgIGZvciAobGV0IGkgaW4gbm9kZU5hbWUpewogICAgICAgICAgbm9kZUNsYXNzLnB1c2gobm9kZU5hbWVbaV0uc3BsaXQoJyAnKS5qb2luKCcnKS5yZXBsYWNlKC9bXlx3XHNdfF8vZywgIiIpKQogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBub2RlQ2xhc3MgPSBub2RlTmFtZS5zcGxpdCgnICcpLmpvaW4oJycpLnJlcGxhY2UoL1teXHdcc118Xy9nLCAiIik7CiAgICAgIH0KCiAgICAgIGlmIChkZWNyZWFzZU9wYWNpdHkpIHsKICAgICAgICBsZXQgb3BhY2l0eSA9IDAuMDE7CgogICAgICAgIC8vIERlY3JlYXNlIG9wYWNpdHkgZm9yIGFsbCBpcnJlbGV2YW50IG5vZGVzIGFuZCB0aGVpciB0ZXh0CiAgICAgICAgZDMuc2VsZWN0QWxsKCIubm9kZS5lbGVtZW50IikudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRoaXMudHJhbnNpdGlvblNwZWVkKS5zdHlsZSgib3BhY2l0eSIsIG9wYWNpdHkpOwogICAgICAgIGQzLnNlbGVjdEFsbCgiLm5vZGUtdGV4dCIpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCBvcGFjaXR5KTsKICAgICAgfQoKICAgICAgLy8gSGlnaGxpZ2h0IHJlbGV2YW50IG5vZGVzIGFuZCB0aGVpciB0ZXh0CiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVDbGFzcykpIHsKICAgICAgICBmb3IgKGxldCBpIGluIG5vZGVDbGFzcyl7CiAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5ub2RlLmVsZW1lbnQuIitub2RlQ2xhc3NbaV0pLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAxKTsKICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLm5vZGUtdGV4dC4iK25vZGVDbGFzc1tpXSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRoaXMudHJhbnNpdGlvblNwZWVkKS5zdHlsZSgib3BhY2l0eSIsIDEpCiAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLHRoaXMuZm9udHNpemUpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBkMy5zZWxlY3RBbGwoIi5ub2RlLmVsZW1lbnQuIitub2RlQ2xhc3MpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAxKTsKICAgICAgICBkMy5zZWxlY3RBbGwoIi5ub2RlLXRleHQuIitub2RlQ2xhc3MpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAxKQogICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsdGhpcy5mb250c2l6ZSk7CiAgICAgIH0KCiAgICAgIC8vIEFwcGxpY2FibGUgb25seSB0byBtb3VzZSBpbnRlcmFjdGlvbnMsIGFuZCBOT1QgdG8gc3RlcHBlcgogICAgICBpZiAoaGlnaGxpZ2h0T3RoZXJzKSB7CiAgICAgICAgbGV0IG90aGVyTm9kZXMgPSB0aGlzLmlkZW50aWZ5VGFyZ2V0cyhub2RlTmFtZSk7CiAgICAgICAgb3RoZXJOb2Rlcy5mb3JFYWNoKG5vZGUgPT4gewogICAgICAgICAgZDMuc2VsZWN0QWxsKCIubm9kZS5lbGVtZW50LiIrIG5vZGUpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAxKTsKICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLm5vZGUtdGV4dC4iKyBub2RlKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy50cmFuc2l0aW9uU3BlZWQpLnN0eWxlKCJvcGFjaXR5IiwgMSkKICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsdGhpcy5mb250c2l6ZSk7CiAgICAgICAgfSkKICAgICAgfQogICAgICAKICAgICAgaWYgKGRlY3JlYXNlT3BhY2l0eSkgewogICAgICAgIC8vIERlY3JlYXNlIG9wYWNpdHkgb2YgaXJyZWxldmFudCBsaW5rcwogICAgICAgIGQzLnNlbGVjdEFsbCgiLmxpbmsuZWxlbWVudCIpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAwKTsKICAgICAgfQoKICAgICAgLy8gSGlnbGlnaHQgbGlua3MKICAgICAgaWYgKGhpZ2hsaWdodExpbmtzKSB7CiAgICAgICAgbGV0IHNvdXJjZSA9IG5vZGVOYW1lLnNwbGl0KCcgJykuam9pbignJykucmVwbGFjZSgvW15cd1xzXXxfL2csICIiKQogICAgICAgIGxldCBzb3VyY2VDbGFzcyA9ICIubGluay5lbGVtZW50LiIgKyBzb3VyY2UKICAgICAgICBkMy5zZWxlY3RBbGwoc291cmNlQ2xhc3MpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAwLjQpOwogICAgICB9CiAgICB9LAoKICAgIGlkZW50aWZ5VGFyZ2V0cyhub2RlTmFtZSkgewogICAgICBsZXQgdGFyZ2V0Tm9kZXMgPSBbXQogICAgICBsZXQgY291bnQgPSAwCiAgICAgIHRoaXMubGlua3MuZm9yRWFjaChsaW5rID0+IHsKICAgICAgICBpZiAobGluay5zb3VyY2UuaWQgPT09IG5vZGVOYW1lIHx8IGxpbmsudGFyZ2V0LmlkID09PSBub2RlTmFtZSl7CiAgICAgICAgICBjb3VudCs9MTsKICAgICAgICB9CiAgICAgICAgaWYgKGxpbmsuc291cmNlLmlkID09PSBub2RlTmFtZSkgewogICAgICAgICAgdGFyZ2V0Tm9kZXMucHVzaChsaW5rLnRhcmdldC5pZC5zcGxpdCgnICcpLmpvaW4oJycpLnJlcGxhY2UoL1teXHdcc118Xy9nLCAiIikpOwogICAgICAgIH0gCiAgICAgICAgCiAgICAgICAgaWYgKGxpbmsudGFyZ2V0LmlkID09PSBub2RlTmFtZSkgewogICAgICAgICAgdGFyZ2V0Tm9kZXMucHVzaChsaW5rLnNvdXJjZS5pZC5zcGxpdCgnICcpLmpvaW4oJycpLnJlcGxhY2UoL1teXHdcc118Xy9nLCAiIikpOwogICAgICAgIH0KICAgICAgfSkKICAgICAgcmV0dXJuIHRhcmdldE5vZGVzCiAgICB9LAoKICAgIG5vZGVNb3VzZW91dChkLCBlLCBub2RlcykgewogICAgICB0aGlzLm5vU2VsZWN0ZWRTdGF0ZShlKTsKICAgICAgdGhpcy4kZm9yY2VVcGRhdGUoKTsKICAgIH0sCgogICAgbm9TZWxlY3RlZFN0YXRlKCkgewogICAgICBkMy5zZWxlY3RBbGwoIi5ub2RlLmVsZW1lbnQiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy50cmFuc2l0aW9uU3BlZWQpLnN0eWxlKCJvcGFjaXR5IiwgMSk7CiAgICAgIGQzLnNlbGVjdEFsbCgiLmxpbmsuZWxlbWVudCIpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAwLjEpOwogICAgICBkMy5zZWxlY3RBbGwoIi5ub2RlLXRleHQiKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy50cmFuc2l0aW9uU3BlZWQpLnN0eWxlKCdvcGFjaXR5JywgZCA9PiBkLm9jY3VyZW5jZSA+IHRoaXMuc2xpZGVyVmFsdWUgPyAxIDogMCk7CiAgICAgIC8vZDMuc2VsZWN0QWxsKCIuZW1waCIpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25TcGVlZCkuc3R5bGUoIm9wYWNpdHkiLCAxKS5hdHRyKCdmb250LXNpemUnLHRoaXMuZm9udHNpemUpOwogICAgfSwKCiAgICByZXNwb25zaXZlZnkoc3ZnKSB7CiAgICAgIC8vIGdldCBjb250YWluZXIgKyBzdmcgYXNwZWN0IHJhdGlvCiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3Qoc3ZnLm5vZGUoKS5wYXJlbnROb2RlKSwKICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQoc3ZnLnN0eWxlKCJ3aWR0aCIpKSwKICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KHN2Zy5zdHlsZSgiaGVpZ2h0IikpLAogICAgICAgICAgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7CgogICAgICAvLyBhZGQgdmlld0JveCBhbmQgcHJlc2VydmVBc3BlY3RSYXRpbyBwcm9wZXJ0aWVzLAogICAgICAvLyBhbmQgY2FsbCByZXNpemUgc28gdGhhdCBzdmcgcmVzaXplcyBvbiBpbml0YWwgcGFnZSBsb2FkCiAgICAgIHN2Zy5hdHRyKCJ2aWV3Qm94IiwgIjAgMCAiICsgd2lkdGggKyAiICIgKyBoZWlnaHQpCiAgICAgICAgICAvLy5hdHRyKCJwZXJzZXJ2ZUFzcGVjdFJhdGlvIiwgInhNaW5ZTWlkIikKICAgICAgICAgIC5jYWxsKHJlc2l6ZSk7CgogICAgICAvLyB0byByZWdpc3RlciBtdWx0aXBsZSBsaXN0ZW5lcnMgZm9yIHNhbWUgZXZlbnQgdHlwZSwgCiAgICAgIC8vIHlvdSBuZWVkIHRvIGFkZCBuYW1lc3BhY2UsIGkuZS4sICdjbGljay5mb28nCiAgICAgIC8vIG5lY2Vzc2FyeSBpZiB5b3UgY2FsbCBpbnZva2UgdGhpcyBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgc3ZncwogICAgICAvLyBhcGkgZG9jczogaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL3dpa2kvU2VsZWN0aW9ucyNvbgogICAgICBkMy5zZWxlY3Qod2luZG93KS5vbigicmVzaXplLiIgKyBjb250YWluZXIuYXR0cigiaWQiKSwgcmVzaXplKTsKCiAgICAgIC8vIGdldCB3aWR0aCBvZiBjb250YWluZXIgYW5kIHJlc2l6ZSBzdmcgdG8gZml0IGl0CiAgICAgIGZ1bmN0aW9uIHJlc2l6ZSgpIHsKICAgICAgICAgIHZhciB0YXJnZXRXaWR0aCA9IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgid2lkdGgiKSkgPiAxMDAwID8gMTAwMCA6IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgid2lkdGgiKSk7CiAgICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gTWF0aC5yb3VuZCh0YXJnZXRXaWR0aCAvIGFzcGVjdCk7CiAgICAgICAgICBzdmcuYXR0cigid2lkdGgiLCB0YXJnZXRXaWR0aCk7CiAgICAgICAgICBzdmcuYXR0cigiaGVpZ2h0IiwgdGFyZ2V0SGVpZ2h0KTsKICAgICAgfQogICAgfSwKCiAgICBpbml0RGF0YSgpIHsKICAgICAgbGV0IGxpbmtEaXN0YW5jZUZ4biA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFsxLCAxNjYzXSkucmFuZ2UoWzUwLCAwXSkKICAgICAgdGhpcy5mb3JjZSA9IGQzCiAgICAgICAgLmZvcmNlU2ltdWxhdGlvbih0aGlzLm5vZGVzKQogICAgICAgIC5mb3JjZSggCiAgICAgICAgICAibGluayIsCiAgICAgICAgICBkMy5mb3JjZUxpbmsodGhpcy5saW5rcykKICAgICAgICAgICAgLmlkKGQgPT4gZC5pZCkKICAgICAgICAgICAgLmRpc3RhbmNlKGQgPT4ge3JldHVybiBsaW5rRGlzdGFuY2VGeG4oZC52YWx1ZSl9KQogICAgICAgICkKICAgICAgICAuZm9yY2UoImNoYXJnZSIsIGQzLmZvcmNlTWFueUJvZHkoKS5zdHJlbmd0aCh0aGlzLmJvZHlTdHJlbmd0aCkpIC8vVGhlIHN0cmVuZ3RoIG9mIHRoZSBhdHRyYWN0aW9uIG9yIHJlcHVsc2lvbgogICAgICAgIC5mb3JjZSgnY29sbGlzaW9uJywgZDMuZm9yY2VDb2xsaWRlKCkucmFkaXVzKGZ1bmN0aW9uKGQpIHsKICAgICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMSwgMTAwMF0pLnJhbmdlKFsxMCwgMTAwXSkoZC5vY2N1cmVuY2UpICsgNQogICAgICAgIH0pKQogICAgICAgIC5mb3JjZSgKICAgICAgICAgICJjZW50ZXIiLAogICAgICAgICAgZDMuZm9yY2VDZW50ZXIodGhpcy5zdmdXaWR0aC8yLCB0aGlzLnN2Z0hlaWdodC8yKQogICAgICAgICkKICAgICAgICAudmVsb2NpdHlEZWNheSgwLjIpOwogICAgfSwKCiAgICBpbml0RHJhZ1RpY2tab29tKCkgewogICAgICBkMy5zZWxlY3RBbGwoIi5ub2RlIikuY2FsbCh0aGlzLmRyYWcodGhpcy5mb3JjZSkpOwoKICAgICAgdGhpcy5mb3JjZS5vbigidGljayIsICgpID0+IHsKICAgICAgICAgZDMuc2VsZWN0QWxsKCIubm9kZSIpCiAgICAgICAgICAuZGF0YSh0aGlzLm5vZGVzKQogICAgICAgICAgLmF0dHIoJ2N4JywgZD0+IGQueCkKICAgICAgICAgIC5hdHRyKCdjeScsIGQ9PiBkLnkpOwogICAgICAgICAgLy8gLmF0dHIoImN4IiwgZCA9PiB7CiAgICAgICAgICAvLyAgIGxldCByYWRpdXMgPSAgZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzEsIDE3MDBdKS5yYW5nZShbNSwgMjBdKShkLm9jY3VyZW5jZSkKICAgICAgICAgIC8vICAgbGV0IG5ld1ggPSBNYXRoLm1heChyYWRpdXMsIE1hdGgubWluKHRoaXMud2lkdGggLSB0aGlzLmJiQm94TWFyZ2luIC0gcmFkaXVzLCBkLngpKTsKICAgICAgICAgIC8vICAgcmV0dXJuIG5ld1gKICAgICAgICAgIC8vIH0pCiAgICAgICAgICAvLyAuYXR0cigiY3kiLCBkID0+IHsKICAgICAgICAgIC8vICAgbGV0IHJhZGl1cyA9ICBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMSwgMTcwMF0pLnJhbmdlKFs1LCAyMF0pKGQub2NjdXJlbmNlKQogICAgICAgICAgLy8gICBsZXQgbmV3WSA9IE1hdGgubWF4KHJhZGl1cywgTWF0aC5taW4odGhpcy5oZWlnaHQgLSB0aGlzLmJiQm94TWFyZ2luIC0gcmFkaXVzLCBkLnkpKTsKICAgICAgICAgIC8vICAgcmV0dXJuIG5ld1kKICAgICAgICAgIC8vIH0pOwoKICAgICAgICBkMy5zZWxlY3RBbGwoIi5ub2RlLXRleHQiKQogICAgICAgICAgLmRhdGEodGhpcy5ub2RlcykKICAgICAgICAgIC5hdHRyKCd4JywgZD0+IGQueCkKICAgICAgICAgIC5hdHRyKCd5JywgZD0+IGQueSk7CiAgICAgICAgICAvLyAuYXR0cigieCIsIGQgPT4gewogICAgICAgICAgLy8gICBsZXQgcmFkaXVzID0gIGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFsxLCAxNzAwXSkucmFuZ2UoWzUsIDIwXSkoZC5vY2N1cmVuY2UpCiAgICAgICAgICAvLyAgIGxldCBuZXdYID0gTWF0aC5tYXgocmFkaXVzLCBNYXRoLm1pbih0aGlzLndpZHRoIC0gdGhpcy5iYkJveE1hcmdpbiAtIHJhZGl1cywgZC54KSk7CiAgICAgICAgICAvLyAgIHJldHVybiBuZXdYCiAgICAgICAgICAvLyB9KQogICAgICAgICAgLy8gLmF0dHIoInkiLCBkID0+IHsKICAgICAgICAgIC8vICAgbGV0IHJhZGl1cyA9ICBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMSwgMTcwMF0pLnJhbmdlKFs1LCAyMF0pKGQub2NjdXJlbmNlKQogICAgICAgICAgLy8gICBsZXQgbmV3WSA9IE1hdGgubWF4KHJhZGl1cywgTWF0aC5taW4odGhpcy5oZWlnaHQgLSB0aGlzLmJiQm94TWFyZ2luIC0gcmFkaXVzLCBkLnkpKTsKICAgICAgICAgIC8vICAgcmV0dXJuIG5ld1kKICAgICAgICAgIC8vIH0pOwoKICAgICAgICBpZiAodGhpcy5jdXJ2ZXMpIHsKICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmxpbmsiKQogICAgICAgICAgLmRhdGEodGhpcy5saW5rcykKICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgbGV0IGR4ID0gZC50YXJnZXQueCAtIGQuc291cmNlLng7CiAgICAgICAgICAgIGxldCBkeSA9IGQudGFyZ2V0LnkgLSBkLnNvdXJjZS55OwogICAgICAgICAgICBsZXQgZHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpOwogICAgICAgICAgICByZXR1cm4gIk0iICsgZC5zb3VyY2UueCArICIsIiArIGQuc291cmNlLnkgKyAiQSIgKyBkciArICIsIiArIGRyICsgIiAxIDAsMSAiICsgZC50YXJnZXQueCArICIsIiArIGQudGFyZ2V0Lnk7CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZDMuc2VsZWN0QWxsKCIubGluayIpCiAgICAgICAgICAuZGF0YSh0aGlzLmxpbmtzKQogICAgICAgICAgLmF0dHIoIngxIiwgZCA9PiBkLnNvdXJjZS54KQogICAgICAgICAgLmF0dHIoInkxIiwgZCA9PiBkLnNvdXJjZS55KQogICAgICAgICAgLmF0dHIoIngyIiwgZCA9PiBkLnRhcmdldC54KQogICAgICAgICAgLmF0dHIoInkyIiwgZCA9PiBkLnRhcmdldC55KTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfSwKCgogICAgZHJhZyhzaW11bGF0aW9uKSB7CiAgICAgIGZ1bmN0aW9uIGRyYWdzdGFydGVkKGQpIHsKICAgICAgICBpZiAoIWQzLmV2ZW50LmFjdGl2ZSkgc2ltdWxhdGlvbi5hbHBoYVRhcmdldCgwLjIpLnJlc3RhcnQoKTsKICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnZml4ZWQnLCBkLmZpeGVkID0gdHJ1ZSk7CiAgICAgICAgZC5meCA9IGQueDsKICAgICAgICBkLmZ5ID0gZC55OwogICAgICB9CgogICAgICBmdW5jdGlvbiBkcmFnZ2VkKGQpIHsKICAgICAgICBkLmZ4ID0gZDMuZXZlbnQueDsKICAgICAgICBkLmZ5ID0gZDMuZXZlbnQueTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gZHJhZ2VuZGVkKGQpIHsKICAgICAgICBpZiAoIWQzLmV2ZW50LmFjdGl2ZSkgc2ltdWxhdGlvbi5hbHBoYVRhcmdldCgwKTsKICAgICAgICBkLmZ4ID0gbnVsbDsKICAgICAgICBkLmZ5ID0gbnVsbDsKICAgICAgfQoKICAgICAgcmV0dXJuIGQzCiAgICAgICAgLmRyYWcoKQogICAgICAgIC5vbigic3RhcnQiLCBkcmFnc3RhcnRlZCkKICAgICAgICAub24oImRyYWciLCBkcmFnZ2VkKQogICAgICAgIC5vbigiZW5kIiwgZHJhZ2VuZGVkKTsKICAgIH0sCiAgfQp9Owo="},{"version":3,"sources":["NetworkC.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"NetworkC.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div id=\"app\" class=\"p-4\" >\n    <div class='inline-flex items-center bg-white w-full'>\n      <div class='flex-col mx-2'>\n       <div class='pr-2 font-bold text-xl'> Active: {{activeScale}}</div>\n       <div class='text-tiny'> {{description[activeScale]}} </div>\n      </div>\n\n      <div class=\"slidecontainer mx-1\">\n        Show labels if mention in cases is above <b>{{sliderValue}}</b>\n        <input type=\"range\" min=\"100\" max=\"2500\" v-model=\"sliderValue\" class=\"slider\" id=\"myRange\">\n      </div>\n\n      <button v-for=\"item in btns\" \n        :key=\"`btn-`+item\"\n        type=\"submit\" \n        :value=\"item\" \n        v-on:click=\"activeScale = item; changeColors();\"\n        class='p-2 mx-3 rounded-full bg-red-400 text-white font-bold hover:bg-red-800'> \n        {{item}} \n      </button>\n    </div>\n    <div id=\"chart\" class=\"justify-center flex my-1 absolute border border-gray-500\"> \n    </div>\n  </div>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\nimport { json, csv } from 'd3-fetch'\n//'../assets/js/mykey.js'\n// DOMTokenList.prototype.indexOf = Array.prototype.indexOf;\n\nexport default {\n  name: \"network\",\n  props: {\n    jsonURL: {\n      type: String,\n      default: () => 'routes_degree.json'\n    },\n\n    linkDistance: {\n      type: Number,\n      default: 30\n    },\n    // svg\n    svgSize: {\n      type: Object,\n      default: () => {\n        return {\n          width: window.innerWidth,\n          height: window.innerHeight\n        };\n      }\n    },\n\n    bodyStrength: {\n      type: Number,\n      default: -200\n    },\n\n    height: {\n      type: Number,\n      default: 800\n    },\n    \n    width: {\n      type: Number,\n      default: 1400\n    },\n\n    sliderValue: {\n      type: Number,\n      default: 100\n    },\n\n    margin: {\n      type: Object,\n      default: function () {\n        return {\n          top: 5,\n          right: 5,\n          bottom: 5,\n          left: 5\n        }\n      }\n    } \n  },\n  data() {\n    return {\n      bbBoxMargin: 20,\n      selection: {\n        links: [],\n        nodes: []\n      },\n      pinned: [], \n      nodeList: [],\n      linkList: [],\n      force: null,\n      zoom: d3.zoom(),\n      transitionSpeed: 200,\n      curves: true,\n      stepper: 0,\n      linkStroke: 'gray',\n      btns: ['d_centrality', 'c_centrality', 'b_centrality'],\n      c_centrality: [],\n      b_centrality: [],\n      d_centrality: [],\n      radiusRange: [1, 10],\n      fontsize:16, \n      activeScale: 'd_centrality',\n      description: {'d_centrality': ' Degree centrality, which is defined as the number of links incident upon a node (i.e., the number of ties that a node has). The degree can be interpreted in terms of the immediate risk of a node for catching whatever is flowing through the network (such as a virus, or some information).',\n        'c_centrality': 'the normalized closeness centrality (or closeness) of a node is the average length of the shortest path between the node and all other nodes in the graph. Thus the more central a node is, the closer it is to all other nodes.',\n        'b_centrality': 'Betweenness centrality quantifies the number of times a node acts as a bridge along the shortest path between two other nodes. It was introduced as a measure for quantifying the control of a human on the communication between other humans in a social network'}\n    };\n  },\n  computed: {\n    nodes() {\n      let nodes = this.nodeList.slice();\n      let nodeIds = [];\n      nodes = nodes.filter(node => {\n        if (nodeIds.indexOf(node.id) === -1) {\n          nodeIds.push(node.id);\n          return true;\n        } else {\n          return false;\n        }\n      });\n      return nodes;\n    },\n\n    links() {\n      return this.linkList;\n    },\n\n    activeDomain() {\n      if (this.activeScale === 'd_centrality') {\n        return this.d_centrality\n      } else if (this.activeScale === 'b_centrality') {\n        return this.b_centrality\n      } else if (this.activeScale === 'c_centrality'){\n        return this.c_centrality\n      }\n    },\n\n    centralityScale() {\n      return d3.scaleLinear().domain(this.activeDomain).range(['white', '#DA0E0E'])\n    } \n  },\n  watch: {\n    sliderValue: function() {\n      this.svg.selectAll('.node-text')\n        .transition().duration(this.transitionSpeed)\n        .attr('opacity', d => d.occurence > this.sliderValue ? 1 : 0);\n      this.$forceUpdate();\n    },\n    bodyStrength: function() {\n      this.initData();\n      this.$nextTick(function() {\n        this.initDragTickZoom();\n      });\n    },\n    linkDistance: function() {\n      this.initData();\n      this.$nextTick(function() {\n        this.initDragTickZoom();\n      });\n    },\n    nodes: function() {\n      this.initData();\n      this.$nextTick(function() {\n        this.initDragTickZoom();\n      });\n    }\n  },\n\n  created() {\n    this.initData();\n  },\n\n  mounted() {\n    this.getData()\n    this.initDragTickZoom();\n  },\n\n  methods: {\n    changeColors(){\n      let nodes = this.svg.selectAll('.node').transition().duration(this.transitionSpeed)\n        .attr('fill', (d) => {console.log(d); return this.centralityScale(d[this.activeScale]);} )\n    },\n\n    update(){\n      d3.select('#chart').select('svg').remove()\n      this.svg = this.getSvg()\n      this.drawChart()\n    },\n\n    getData () {\n      if (!this.jsonURL) {\n        throw new Error('Please provide either data or jsonURL')\n      } else {\n        this.processJSON(this.jsonURL)\n      }\n    },\n\n    getString(row) {\n      let label = row['country'].includes('mean') ? 'Average value for ' + row['element'] : row['country'] \n      let value = label + ': ' + (row[this.activeIndex] ? Math.round(row[this.activeIndex] * 10) / 10 : 'NIL')\n      return value\n    },\n\n    processJSON (url) {\n      json(url).then((data) => {\n        this.linkList = data.links\n        this.nodeList = data.nodes\n\n        this.nodeList.forEach( node=> {\n          this.c_centrality.push(node.c_centrality)\n          this.b_centrality.push(node.b_centrality)\n          this.d_centrality.push(node.d_centrality)\n        })\n\n        this.c_centrality = [0, d3.extent(this.c_centrality)[1]]\n        this.b_centrality = [0, d3.extent(this.b_centrality)[1]]\n        this.d_centrality = [0, d3.extent(this.d_centrality)[1]]\n        this.mount = true\n        this.update()\n      })\n    },\n\n    getSvg () {\n      const { svgWidth, svgHeight } = this\n      const { margin } = this\n\n      this.svgWidth = this.width\n      this.svgHeight = this.height\n      const width = this.svgWidth + margin.left + margin.right\n      const height = this.svgHeight + margin.top + margin.bottom\n\n      let svg = d3.select(\"#chart\").append(\"svg\")\n              .attr(\"width\", width)\n              .attr(\"height\", height)\n              .attr(\"id\", \"container\");\n              //.call(this.responsivefy);\n\n      return svg\n    },\n\n    drawChart() {\n      let g = this.svg.append('g')\n\n      let edges \n      if (this.curves) {\n        edges = g.append(\"g\")\n          .selectAll(\".link\")\n          .data(this.links)\n          .join(\"path\")\n          .attr(\"opacity\", 0.1)\n          .attr(\"stroke\", this.linkStroke)\n          .attr(\"fill\", \"transparent\")\n          .attr('class', function(d) {\n          \n            let source = d.source.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n            let target = d.target.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n            return 'link element ' + source + ' ' + target;\n            })\n          .attr('stroke-linecap', 'round')\n          .attr('stroke-width', function (d) {\n            return d3.scaleLinear().domain([5, 10]).range([1, 20])(d.value);\n          });\n      } else {\n        edges = g.append(\"g\")\n        .selectAll(\".link\")\n        .data(this.links)\n        .enter().append(\"line\")\n        .attr('class', function(d) {\n          let source = d.source.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n          let target = d.target.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n          return 'link element ' + source + ' ' + target;\n          })\n        .attr('opacity', 0.1)\n        .attr('stroke-linecap', 'round')\n        .attr('stroke', this.linkStroke)\n        .attr('stroke-width', function (d) {\n            return d3.scaleLinear().domain([1, 30]).range([1, 30])(d.value);\n          });\n      }\n\n      let nodes = g.append(\"g\")\n        .selectAll(\".node\")\n        .data(this.nodes)\n        .enter().append('circle')\n        .attr('id', (d) => d.index)\n        .attr('class', function(d) {\n          let nodeClass=''\n          return 'node element ' + d.id.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n          })\n        .attr('fill', (d) => this.centralityScale(d[this.activeScale]))\n        .attr('stroke', (d) => d.child === true ? 'goldenrod' : 'black')\n        .attr('stroke-width', 2)\n        .attr('r', (d) => d3.scaleLinear().domain([1, 100]).range(this.radiusRange)(d.occurence))\n        .on('mouseover', (d, e, nodes) => this.nodeMouseover(d, e, nodes))\n        .on('mouseout', (d, e, nodes) => this.nodeMouseout(d, e, nodes));\n\n      let blackOut = this.blackOut\n      \n      //Add single line text\n      g.append(\"g\")\n        .selectAll(\".text\")\n        .data(this.nodes)\n        .enter()\n        .append('text')\n        .attr('class', (d) => {\n          if (d.occurence > this.sliderValue) {\n            return 'emph node-text ' + d.id.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n          }\n\n          return 'node-text ' + d.id.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n        })\n        .text((d) => d.id)\n        .attr('fill', 'black')\n        .attr('dx', 0)\n        .attr('alignment-baseline', 'text-top')\n        .attr('text-anchor', 'middle')\n        .attr('font-size',this.fontsize)\n        .attr('opacity', (d) => d.occurence > this.sliderValue ? 1 : 0)\n        .on('mouseover', (d, e, nodes) => this.nodeMouseover(d, e, nodes))\n        .on('mouseout', (d, e, nodes) => this.nodeMouseout(d, e, nodes));\n\n      this.initDragTickZoom()\n\n      let zoomLvl = 0.5;\n      let lastK = 0;\n      \n      this.svg.call(d3.zoom()\n      .extent([[0, 0], [this.svgWidth, this.svgHeight]])\n      .scaleExtent([0.25, 80])\n      .on(\"zoom\", zoomed));\n\n      function zoomed() {\n        let e = d3.event\n        \n        if(e.transform.k > 2 && lastK != e.transform.k){\n          lastK = e.transform.k;\n          // console.log(\"zoomed\");\n          zoomLvl =Math.log2(e.transform.k);\n          nodes.attr(\"stroke-width\", 1.5/zoomLvl );\n          edges.attr(\"stroke-width\",  d => Math.sqrt(d.value)/(zoomLvl));\n        }\n      \n        g.attr(\"transform\", e.transform);\n      }\n    },\n\n    nodeMouseover(d, e, nodes) {\n      let targetNode = nodes[e]\n      this.activeNode = d.id\n      this.highlightNode(this.activeNode, true, true, true);\n      this.$forceUpdate();\n    },\n\n    highlightNode(nodeName, highlightLinks, highlightOthers, decreaseOpacity){\n      let nodeClass = []\n      \n      if (Array.isArray(nodeName)) {\n        for (let i in nodeName){\n          nodeClass.push(nodeName[i].split(' ').join('').replace(/[^\\w\\s]|_/g, \"\"))\n        }\n      } else {\n        nodeClass = nodeName.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\");\n      }\n\n      if (decreaseOpacity) {\n        let opacity = 0.01;\n\n        // Decrease opacity for all irrelevant nodes and their text\n        d3.selectAll(\".node.element\").transition().duration(this.transitionSpeed).style(\"opacity\", opacity);\n        d3.selectAll(\".node-text\").transition().duration(this.transitionSpeed).style(\"opacity\", opacity);\n      }\n\n      // Highlight relevant nodes and their text\n      if (Array.isArray(nodeClass)) {\n        for (let i in nodeClass){\n          d3.selectAll(\".node.element.\"+nodeClass[i]).transition().duration(this.transitionSpeed).style(\"opacity\", 1);\n          d3.selectAll(\".node-text.\"+nodeClass[i]).transition().duration(this.transitionSpeed).style(\"opacity\", 1)\n            .attr('font-size',this.fontsize);\n        }\n      } else {\n        d3.selectAll(\".node.element.\"+nodeClass).transition().duration(this.transitionSpeed).style(\"opacity\", 1);\n        d3.selectAll(\".node-text.\"+nodeClass).transition().duration(this.transitionSpeed).style(\"opacity\", 1)\n          .attr('font-size',this.fontsize);\n      }\n\n      // Applicable only to mouse interactions, and NOT to stepper\n      if (highlightOthers) {\n        let otherNodes = this.identifyTargets(nodeName);\n        otherNodes.forEach(node => {\n          d3.selectAll(\".node.element.\"+ node).transition().duration(this.transitionSpeed).style(\"opacity\", 1);\n          d3.selectAll(\".node-text.\"+ node).transition().duration(this.transitionSpeed).style(\"opacity\", 1)\n            .attr('font-size',this.fontsize);\n        })\n      }\n      \n      if (decreaseOpacity) {\n        // Decrease opacity of irrelevant links\n        d3.selectAll(\".link.element\").transition().duration(this.transitionSpeed).style(\"opacity\", 0);\n      }\n\n      // Higlight links\n      if (highlightLinks) {\n        let source = nodeName.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\")\n        let sourceClass = \".link.element.\" + source\n        d3.selectAll(sourceClass).transition().duration(this.transitionSpeed).style(\"opacity\", 0.4);\n      }\n    },\n\n    identifyTargets(nodeName) {\n      let targetNodes = []\n      let count = 0\n      this.links.forEach(link => {\n        if (link.source.id === nodeName || link.target.id === nodeName){\n          count+=1;\n        }\n        if (link.source.id === nodeName) {\n          targetNodes.push(link.target.id.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\"));\n        } \n        \n        if (link.target.id === nodeName) {\n          targetNodes.push(link.source.id.split(' ').join('').replace(/[^\\w\\s]|_/g, \"\"));\n        }\n      })\n      return targetNodes\n    },\n\n    nodeMouseout(d, e, nodes) {\n      this.noSelectedState(e);\n      this.$forceUpdate();\n    },\n\n    noSelectedState() {\n      d3.selectAll(\".node.element\").transition().duration(this.transitionSpeed).style(\"opacity\", 1);\n      d3.selectAll(\".link.element\").transition().duration(this.transitionSpeed).style(\"opacity\", 0.1);\n      d3.selectAll(\".node-text\").transition().duration(this.transitionSpeed).style('opacity', d => d.occurence > this.sliderValue ? 1 : 0);\n      //d3.selectAll(\".emph\").transition().duration(this.transitionSpeed).style(\"opacity\", 1).attr('font-size',this.fontsize);\n    },\n\n    responsivefy(svg) {\n      // get container + svg aspect ratio\n      var container = d3.select(svg.node().parentNode),\n          width = parseInt(svg.style(\"width\")),\n          height = parseInt(svg.style(\"height\")),\n          aspect = width / height;\n\n      // add viewBox and preserveAspectRatio properties,\n      // and call resize so that svg resizes on inital page load\n      svg.attr(\"viewBox\", \"0 0 \" + width + \" \" + height)\n          //.attr(\"perserveAspectRatio\", \"xMinYMid\")\n          .call(resize);\n\n      // to register multiple listeners for same event type, \n      // you need to add namespace, i.e., 'click.foo'\n      // necessary if you call invoke this function for multiple svgs\n      // api docs: https://github.com/mbostock/d3/wiki/Selections#on\n      d3.select(window).on(\"resize.\" + container.attr(\"id\"), resize);\n\n      // get width of container and resize svg to fit it\n      function resize() {\n          var targetWidth = parseInt(container.style(\"width\")) > 1000 ? 1000 : parseInt(container.style(\"width\"));\n          var targetHeight = Math.round(targetWidth / aspect);\n          svg.attr(\"width\", targetWidth);\n          svg.attr(\"height\", targetHeight);\n      }\n    },\n\n    initData() {\n      let linkDistanceFxn = d3.scaleLinear().domain([1, 1663]).range([50, 0])\n      this.force = d3\n        .forceSimulation(this.nodes)\n        .force( \n          \"link\",\n          d3.forceLink(this.links)\n            .id(d => d.id)\n            .distance(d => {return linkDistanceFxn(d.value)})\n        )\n        .force(\"charge\", d3.forceManyBody().strength(this.bodyStrength)) //The strength of the attraction or repulsion\n        .force('collision', d3.forceCollide().radius(function(d) {\n          return d3.scaleLinear().domain([1, 1000]).range([10, 100])(d.occurence) + 5\n        }))\n        .force(\n          \"center\",\n          d3.forceCenter(this.svgWidth/2, this.svgHeight/2)\n        )\n        .velocityDecay(0.2);\n    },\n\n    initDragTickZoom() {\n      d3.selectAll(\".node\").call(this.drag(this.force));\n\n      this.force.on(\"tick\", () => {\n         d3.selectAll(\".node\")\n          .data(this.nodes)\n          .attr('cx', d=> d.x)\n          .attr('cy', d=> d.y);\n          // .attr(\"cx\", d => {\n          //   let radius =  d3.scaleLinear().domain([1, 1700]).range([5, 20])(d.occurence)\n          //   let newX = Math.max(radius, Math.min(this.width - this.bbBoxMargin - radius, d.x));\n          //   return newX\n          // })\n          // .attr(\"cy\", d => {\n          //   let radius =  d3.scaleLinear().domain([1, 1700]).range([5, 20])(d.occurence)\n          //   let newY = Math.max(radius, Math.min(this.height - this.bbBoxMargin - radius, d.y));\n          //   return newY\n          // });\n\n        d3.selectAll(\".node-text\")\n          .data(this.nodes)\n          .attr('x', d=> d.x)\n          .attr('y', d=> d.y);\n          // .attr(\"x\", d => {\n          //   let radius =  d3.scaleLinear().domain([1, 1700]).range([5, 20])(d.occurence)\n          //   let newX = Math.max(radius, Math.min(this.width - this.bbBoxMargin - radius, d.x));\n          //   return newX\n          // })\n          // .attr(\"y\", d => {\n          //   let radius =  d3.scaleLinear().domain([1, 1700]).range([5, 20])(d.occurence)\n          //   let newY = Math.max(radius, Math.min(this.height - this.bbBoxMargin - radius, d.y));\n          //   return newY\n          // });\n\n        if (this.curves) {\n          d3.selectAll(\".link\")\n          .data(this.links)\n          .attr('d', function (d) {\n            let dx = d.target.x - d.source.x;\n            let dy = d.target.y - d.source.y;\n            let dr = Math.sqrt(dx * dx + dy * dy);\n            return \"M\" + d.source.x + \",\" + d.source.y + \"A\" + dr + \",\" + dr + \" 1 0,1 \" + d.target.x + \",\" + d.target.y;\n          });\n        } else {\n          d3.selectAll(\".link\")\n          .data(this.links)\n          .attr(\"x1\", d => d.source.x)\n          .attr(\"y1\", d => d.source.y)\n          .attr(\"x2\", d => d.target.x)\n          .attr(\"y2\", d => d.target.y);\n        }\n      });\n    },\n\n\n    drag(simulation) {\n      function dragstarted(d) {\n        if (!d3.event.active) simulation.alphaTarget(0.2).restart();\n        d3.select(this).classed('fixed', d.fixed = true);\n        d.fx = d.x;\n        d.fy = d.y;\n      }\n\n      function dragged(d) {\n        d.fx = d3.event.x;\n        d.fy = d3.event.y;\n      }\n\n      function dragended(d) {\n        if (!d3.event.active) simulation.alphaTarget(0);\n        d.fx = null;\n        d.fy = null;\n      }\n\n      return d3\n        .drag()\n        .on(\"start\", dragstarted)\n        .on(\"drag\", dragged)\n        .on(\"end\", dragended);\n    },\n  }\n};\n</script>\n\n<style>\n@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap');\n</style>\n\n<style scoped>\n.app {\n  display: inline-block;\n  position: relative;\n}\n\n.element {\n  transition: opacity 0.2s ease;\n}\n.selected {\n  opacity: 0.9 !important;\n}\n\n.node,\n.link {\n  cursor: pointer;\n}\n</style>\n\n"]}]}